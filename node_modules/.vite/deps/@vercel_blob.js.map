{
  "version": 3,
  "sources": ["../../@vercel/blob/dist/undici-browser.js", "../../@vercel/blob/src/helpers.ts", "../../@vercel/blob/src/put.ts", "../../@vercel/blob/src/del.ts", "../../@vercel/blob/src/head.ts", "../../@vercel/blob/src/list.ts", "../../@vercel/blob/src/copy.ts", "../../@vercel/blob/src/index.ts"],
  "sourcesContent": ["// this file gets copied to the dist folder\n// it makes undici work in the browser by reusing the global fetch\n// it's the simplest way I've found to make http requests work in Node.js, Serverles Functions, Edge Functions, and the browser\n// this should work as long as this module is used via Next.js/Webpack\n// moving forward we will have to solve this problem in a more robust way\n// reusing https://github.com/inrupt/universal-fetch\n// or seeing how/if cross-fetch solves https://github.com/lquixada/cross-fetch/issues/69\nexport const fetch = globalThis.fetch;\n", "// common util interface for blob raw commands, not meant to be used directly\n// this is why it's not exported from index/client\n\nimport { type Response } from 'undici';\n\nexport interface BlobCommandOptions {\n  /**\n   * Define your blob API token.\n   * @defaultvalue process.env.BLOB_READ_WRITE_TOKEN\n   */\n  token?: string;\n}\n\n// shared interface for put and copy\nexport interface CreateBlobCommandOptions extends BlobCommandOptions {\n  /**\n   * Whether the blob should be publicly accessible. Support for private blobs is planned.\n   */\n  access: 'public';\n  /**\n   * Adds a random suffix to the filename.\n   * @defaultvalue true\n   */\n  addRandomSuffix?: boolean;\n  /**\n   * Defines the content type of the blob. By default, this value is inferred from the pathname. Sent as the 'content-type' header when downloading a blob.\n   */\n  contentType?: string;\n  /**\n   * Number in seconds to configure the edge and browser cache. The maximum values are 5 minutes for the edge cache and unlimited for the browser cache.\n   * Detailed documentation can be found here: https://vercel.com/docs/storage/vercel-blob#caching\n   * @defaultvalue 365 * 24 * 60 * 60 (1 Year)\n   */\n  cacheControlMaxAge?: number;\n}\n\nexport function getTokenFromOptionsOrEnv(options?: BlobCommandOptions): string {\n  if (options?.token) {\n    return options.token;\n  }\n\n  if (process.env.BLOB_READ_WRITE_TOKEN) {\n    return process.env.BLOB_READ_WRITE_TOKEN;\n  }\n\n  throw new BlobError(\n    'No token found. Either configure the `BLOB_READ_WRITE_TOKEN` environment variable, or pass a `token` option to your calls.',\n  );\n}\n\nexport class BlobError extends Error {\n  constructor(message: string) {\n    super(`Vercel Blob: ${message}`);\n  }\n}\n\nexport class BlobAccessError extends BlobError {\n  constructor() {\n    super('Access denied, please provide a valid token for this resource');\n  }\n}\n\nexport class BlobStoreNotFoundError extends BlobError {\n  constructor() {\n    super('This store does not exist');\n  }\n}\n\nexport class BlobStoreSuspendedError extends BlobError {\n  constructor() {\n    super('This store has been suspended');\n  }\n}\n\nexport class BlobUnknownError extends BlobError {\n  constructor() {\n    super('Unknown error, please visit https://vercel.com/help');\n  }\n}\n\nexport class BlobNotFoundError extends BlobError {\n  constructor() {\n    super('The requested blob does not exist');\n  }\n}\n\ntype BlobApiErrorCodes =\n  | 'store_suspended'\n  | 'forbidden'\n  | 'not_found'\n  | 'unknown_error'\n  | 'bad_request'\n  | 'store_not_found'\n  | 'not_allowed';\n\ninterface BlobApiError {\n  error?: { code?: BlobApiErrorCodes; message?: string };\n}\n\nexport async function validateBlobApiResponse(\n  response: Response,\n): Promise<void> {\n  if (!response.ok) {\n    if (response.status >= 500) {\n      throw new BlobUnknownError();\n    } else {\n      let data: unknown;\n      try {\n        data = await response.json();\n      } catch {\n        throw new BlobUnknownError();\n      }\n      const error = (data as BlobApiError).error;\n\n      switch (error?.code) {\n        case 'store_suspended':\n          throw new BlobStoreSuspendedError();\n        case 'forbidden':\n          throw new BlobAccessError();\n        case 'not_found':\n          throw new BlobNotFoundError();\n        case 'store_not_found':\n          throw new BlobStoreNotFoundError();\n        case 'bad_request':\n          throw new BlobError(error.message ?? 'Bad request');\n        case 'unknown_error':\n        case 'not_allowed':\n        default:\n          throw new BlobUnknownError();\n      }\n    }\n  }\n}\n\n// This version is used to ensure that the client and server are compatible\n// The server (Vercel Blob API) uses this information to change its behavior like the\n// response format\nconst BLOB_API_VERSION = 5;\n\nexport function getApiVersionHeader(): { 'x-api-version'?: string } {\n  let versionOverride = null;\n  try {\n    // wrapping this code in a try/catch as this function is used in the browser and Vite doesn't define the process.env.\n    // As this varaible is NOT used in production, it will always default to the BLOB_API_VERSION\n    versionOverride =\n      process.env.VERCEL_BLOB_API_VERSION_OVERRIDE ||\n      process.env.NEXT_PUBLIC_VERCEL_BLOB_API_VERSION_OVERRIDE;\n  } catch {\n    // noop\n  }\n\n  return {\n    'x-api-version': `${versionOverride ?? BLOB_API_VERSION}`,\n  };\n}\n\nexport function getApiUrl(pathname = ''): string {\n  let baseUrl = null;\n  try {\n    // wrapping this code in a try/catch as this function is used in the browser and Vite doesn't define the process.env.\n    // As this varaible is NOT used in production, it will always default to production endpoint\n    baseUrl =\n      process.env.VERCEL_BLOB_API_URL ||\n      process.env.NEXT_PUBLIC_VERCEL_BLOB_API_URL;\n  } catch {\n    // noop\n  }\n  return `${baseUrl || 'https://blob.vercel-storage.com'}${pathname}`;\n}\n", "import type { Readable } from 'node:stream';\nimport type { BodyInit } from 'undici';\nimport { fetch } from 'undici';\nimport type { ClientPutCommandOptions } from './client';\nimport type { CreateBlobCommandOptions } from './helpers';\nimport {\n  getApiUrl,\n  getApiVersionHeader,\n  getTokenFromOptionsOrEnv,\n  BlobError,\n  validateBlobApiResponse,\n} from './helpers';\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface -- expose option interface for each API method for better extensibility in the future\nexport interface PutCommandOptions extends CreateBlobCommandOptions {}\n\nconst putOptionHeaderMap = {\n  cacheControlMaxAge: 'x-cache-control-max-age',\n  addRandomSuffix: 'x-add-random-suffix',\n  contentType: 'x-content-type',\n};\n\nexport interface PutBlobResult {\n  url: string;\n  pathname: string;\n  contentType: string;\n  contentDisposition: string;\n}\n\nexport type PutBlobApiResponse = PutBlobResult;\n\ntype PartialBy<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;\n\nexport function createPutMethod<\n  T extends PartialBy<PutCommandOptions & ClientPutCommandOptions, 'token'>,\n>({\n  allowedOptions,\n  getToken,\n  extraChecks,\n}: {\n  allowedOptions: (keyof typeof putOptionHeaderMap)[];\n  getToken?: (pathname: string, options: T) => Promise<string>;\n  extraChecks?: (options: T) => void;\n}) {\n  return async function put(\n    pathname: string,\n    body:\n      | string\n      | Readable\n      | Blob\n      | ArrayBuffer\n      | FormData\n      | ReadableStream\n      | File,\n    options?: T,\n  ): Promise<PutBlobResult> {\n    if (!pathname) {\n      throw new BlobError('pathname is required');\n    }\n\n    if (!body) {\n      throw new BlobError('body is required');\n    }\n\n    if (!options) {\n      throw new BlobError('missing options, see usage');\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- Runtime check for DX.\n    if (options.access !== 'public') {\n      throw new BlobError('access must be \"public\"');\n    }\n\n    if (extraChecks) {\n      extraChecks(options);\n    }\n\n    const token = getToken\n      ? await getToken(pathname, options)\n      : getTokenFromOptionsOrEnv(options);\n\n    const headers: Record<string, string> = {\n      ...getApiVersionHeader(),\n      authorization: `Bearer ${token}`,\n    };\n\n    if (allowedOptions.includes('contentType') && options.contentType) {\n      headers['x-content-type'] = options.contentType;\n    }\n\n    if (\n      allowedOptions.includes('addRandomSuffix') &&\n      options.addRandomSuffix !== undefined\n    ) {\n      headers['x-add-random-suffix'] = options.addRandomSuffix ? '1' : '0';\n    }\n\n    if (\n      allowedOptions.includes('cacheControlMaxAge') &&\n      options.cacheControlMaxAge !== undefined\n    ) {\n      headers['x-cache-control-max-age'] =\n        options.cacheControlMaxAge.toString();\n    }\n\n    const blobApiResponse = await fetch(getApiUrl(`/${pathname}`), {\n      method: 'PUT',\n      body: body as BodyInit,\n      headers,\n      // required in order to stream some body types to Cloudflare\n      // currently only supported in Node.js, we may have to feature detect this\n      duplex: 'half',\n    });\n\n    await validateBlobApiResponse(blobApiResponse);\n\n    const blobResult = (await blobApiResponse.json()) as PutBlobApiResponse;\n\n    return blobResult;\n  };\n}\n", "import { fetch } from 'undici';\nimport type { BlobCommandOptions } from './helpers';\nimport {\n  getApiUrl,\n  getApiVersionHeader,\n  getTokenFromOptionsOrEnv,\n  validateBlobApiResponse,\n} from './helpers';\n\ntype DeleteBlobApiResponse = null;\n\n/**\n * Deletes one or multiple blobs from your store.\n * Detailed documentation can be found here: https://vercel.com/docs/storage/vercel-blob/using-blob-sdk#delete-a-blob\n *\n * @param url - Blob url or array of blob urls that identify the blobs to be deleted. You can only delete blobs that are located in a store, that your 'BLOB_READ_WRITE_TOKEN' has access to.\n * @param options - Additional options for the request.\n */\nexport async function del(\n  url: string[] | string,\n  options?: BlobCommandOptions,\n): Promise<void> {\n  const blobApiResponse = await fetch(getApiUrl('/delete'), {\n    method: 'POST',\n    headers: {\n      ...getApiVersionHeader(),\n      authorization: `Bearer ${getTokenFromOptionsOrEnv(options)}`,\n      'content-type': 'application/json',\n    },\n    body: JSON.stringify({ urls: Array.isArray(url) ? url : [url] }),\n  });\n\n  await validateBlobApiResponse(blobApiResponse);\n\n  (await blobApiResponse.json()) as DeleteBlobApiResponse;\n}\n", "import { fetch } from 'undici';\nimport type { BlobCommandOptions } from './helpers';\nimport {\n  getApiUrl,\n  getApiVersionHeader,\n  getTokenFromOptionsOrEnv,\n  validateBlobApiResponse,\n} from './helpers';\n\nexport interface HeadBlobResult {\n  url: string;\n  size: number;\n  uploadedAt: Date;\n  pathname: string;\n  contentType: string;\n  contentDisposition: string;\n  cacheControl: string;\n}\n\ninterface HeadBlobApiResponse extends Omit<HeadBlobResult, 'uploadedAt'> {\n  uploadedAt: string; // when receiving data from our API, uploadedAt is a string\n}\n\n/**\n * Fetches metadata of a blob object.\n * Detailed documentation can be found here: https://vercel.com/docs/storage/vercel-blob/using-blob-sdk#get-blob-metadata\n *\n * @param url - Blob url to lookup.\n * @param options - Additional options for the request.\n */\nexport async function head(\n  url: string,\n  options?: BlobCommandOptions,\n): Promise<HeadBlobResult> {\n  const headApiUrl = new URL(getApiUrl());\n  headApiUrl.searchParams.set('url', url);\n\n  const blobApiResponse = await fetch(headApiUrl, {\n    method: 'GET', // HEAD can't have body as a response, so we use GET\n    headers: {\n      ...getApiVersionHeader(),\n      authorization: `Bearer ${getTokenFromOptionsOrEnv(options)}`,\n    },\n  });\n\n  await validateBlobApiResponse(blobApiResponse);\n\n  const headResult = (await blobApiResponse.json()) as HeadBlobApiResponse;\n\n  return mapBlobResult(headResult);\n}\n\nfunction mapBlobResult(blobResult: HeadBlobApiResponse): HeadBlobResult;\n\nfunction mapBlobResult(blobResult: HeadBlobApiResponse): HeadBlobResult {\n  return {\n    ...blobResult,\n    uploadedAt: new Date(blobResult.uploadedAt),\n  };\n}\n", "import { fetch } from 'undici';\nimport type { BlobCommandOptions } from './helpers';\nimport {\n  getApiUrl,\n  getApiVersionHeader,\n  getTokenFromOptionsOrEnv,\n  validateBlobApiResponse,\n} from './helpers';\n\nexport interface ListBlobResultBlob {\n  url: string;\n  pathname: string;\n  size: number;\n  uploadedAt: Date;\n}\n\nexport interface ListBlobResult {\n  blobs: ListBlobResultBlob[];\n  cursor?: string;\n  hasMore: boolean;\n}\n\nexport interface ListFoldedBlobResult extends ListBlobResult {\n  folders: string[];\n}\n\ninterface ListBlobApiResponseBlob\n  extends Omit<ListBlobResultBlob, 'uploadedAt'> {\n  uploadedAt: string;\n}\n\ninterface ListBlobApiResponse extends Omit<ListBlobResult, 'blobs'> {\n  blobs: ListBlobApiResponseBlob[];\n  folders?: string[];\n}\n\nexport interface ListCommandOptions<\n  M extends 'expanded' | 'folded' | undefined = undefined,\n> extends BlobCommandOptions {\n  /**\n   * The maximum number of blobs to return.\n   * @defaultvalue 1000\n   */\n  limit?: number;\n  /**\n   * Filters the result to only include blobs that start with this prefix.\n   * If used together with `mode: 'folded'`, make sure to include a trailing slash after the foldername.\n   */\n  prefix?: string;\n  /**\n   * The cursor to use for pagination. Can be obtained from the response of a previous `list` request.\n   */\n  cursor?: string;\n  /**\n   * Defines how the blobs are listed\n   * - `expanded` the blobs property contains all blobs.\n   * - `folded` the blobs property contains only the blobs at the root level of your store. Blobs that are located inside a folder get merged into a single entry in the folder response property.\n   * @defaultvalue 'expanded'\n   */\n  mode?: M;\n}\n\ntype ListCommandResult<\n  M extends 'expanded' | 'folded' | undefined = undefined,\n> = M extends 'folded' ? ListFoldedBlobResult : ListBlobResult;\n\n/**\n * Fetches a paginated list of blob objects from your store.\n * Detailed documentation can be found here: https://vercel.com/docs/storage/vercel-blob/using-blob-sdk#list-blobs\n *\n * @param options - Additional options for the request.\n */\nexport async function list<\n  M extends 'expanded' | 'folded' | undefined = undefined,\n>(options?: ListCommandOptions<M>): Promise<ListCommandResult<M>> {\n  const listApiUrl = new URL(getApiUrl());\n  if (options?.limit) {\n    listApiUrl.searchParams.set('limit', options.limit.toString());\n  }\n  if (options?.prefix) {\n    listApiUrl.searchParams.set('prefix', options.prefix);\n  }\n  if (options?.cursor) {\n    listApiUrl.searchParams.set('cursor', options.cursor);\n  }\n  if (options?.mode) {\n    listApiUrl.searchParams.set('mode', options.mode);\n  }\n\n  const blobApiResponse = await fetch(listApiUrl, {\n    method: 'GET',\n    headers: {\n      ...getApiVersionHeader(),\n      authorization: `Bearer ${getTokenFromOptionsOrEnv(options)}`,\n    },\n  });\n\n  await validateBlobApiResponse(blobApiResponse);\n\n  const results = (await blobApiResponse.json()) as ListBlobApiResponse;\n\n  if (options?.mode === 'folded') {\n    return {\n      folders: results.folders ?? [],\n      cursor: results.cursor,\n      hasMore: results.hasMore,\n      blobs: results.blobs.map(mapBlobResult),\n    } as ListCommandResult<M>;\n  }\n\n  return {\n    cursor: results.cursor,\n    hasMore: results.hasMore,\n    blobs: results.blobs.map(mapBlobResult),\n  } as ListCommandResult<M>;\n}\n\nfunction mapBlobResult(\n  blobResult: ListBlobApiResponseBlob,\n): ListBlobResultBlob {\n  return {\n    ...blobResult,\n    uploadedAt: new Date(blobResult.uploadedAt),\n  };\n}\n", "import { fetch } from 'undici';\nimport type { CreateBlobCommandOptions } from './helpers';\nimport {\n  BlobError,\n  getApiUrl,\n  getApiVersionHeader,\n  getTokenFromOptionsOrEnv,\n  validateBlobApiResponse,\n} from './helpers';\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface -- expose option interface for each API method for better extensibility in the future\nexport interface CopyCommandOptions extends CreateBlobCommandOptions {}\n\nexport interface CopyBlobResult {\n  url: string;\n  pathname: string;\n  contentType?: string;\n  contentDisposition: string;\n}\n\n/**\n * Copies a blob to another location in your store.\n * Detailed documentation can be found here: https://vercel.com/docs/storage/vercel-blob/using-blob-sdk#copy-a-blob\n *\n * @param fromUrl - The blob URL to copy. You can only copy blobs that are in the store, that your 'BLOB_READ_WRITE_TOKEN' has access to.\n * @param toPathname - The pathname to copy the blob to. This includes the filename.\n * @param options - Additional options. The copy method will not preserve any metadata configuration (e.g.: 'cacheControlMaxAge') of the source blob. If you want to copy the metadata, you need to define it here again.\n */\nexport async function copy(\n  fromUrl: string,\n  toPathname: string,\n  options: CopyCommandOptions,\n): Promise<CopyBlobResult> {\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- Runtime check for DX.\n  if (!options) {\n    throw new BlobError('missing options, see usage');\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- Runtime check for DX.\n  if (options.access !== 'public') {\n    throw new BlobError('access must be \"public\"');\n  }\n\n  const headers: Record<string, string> = {\n    ...getApiVersionHeader(),\n    authorization: `Bearer ${getTokenFromOptionsOrEnv(options)}`,\n  };\n\n  if (options.addRandomSuffix !== undefined) {\n    headers['x-add-random-suffix'] = options.addRandomSuffix ? '1' : '0';\n  }\n\n  if (options.contentType) {\n    headers['x-content-type'] = options.contentType;\n  }\n\n  if (options.cacheControlMaxAge !== undefined) {\n    headers['x-cache-control-max-age'] = options.cacheControlMaxAge.toString();\n  }\n\n  const blobApiResponse = await fetch(\n    getApiUrl(`/${toPathname}?fromUrl=${fromUrl}`),\n    { method: 'PUT', headers },\n  );\n\n  await validateBlobApiResponse(blobApiResponse);\n\n  return (await blobApiResponse.json()) as CopyBlobResult;\n}\n", "import type { PutCommandOptions } from './put';\nimport { createPutMethod } from './put';\n\n// expose the BlobError types\nexport {\n  BlobAccessError,\n  BlobError,\n  BlobNotFoundError,\n  BlobStoreNotFoundError,\n  BlobStoreSuspendedError,\n  BlobUnknownError,\n} from './helpers';\n\n// vercelBlob.put()\n\nexport type { PutBlobResult, PutCommandOptions } from './put';\n\n/**\n * Uploads a blob into your store from your server.\n * Detailed documentation can be found here: https://vercel.com/docs/storage/vercel-blob/using-blob-sdk#upload-a-blob\n *\n * If you want to upload from the browser directly, check out the documentation for client uploads: https://vercel.com/docs/storage/vercel-blob/using-blob-sdk#client-uploads\n *\n * @param pathname - The pathname to upload the blob to. This includes the filename.\n * @param body - The contents of your blob. This has to be a supported fetch body type https://developer.mozilla.org/en-US/docs/Web/API/fetch#body.\n * @param options - Additional options like `token` or `contentType`.\n */\nexport const put = createPutMethod<PutCommandOptions>({\n  allowedOptions: ['cacheControlMaxAge', 'addRandomSuffix', 'contentType'],\n});\n\n//  vercelBlob.del()\n\nexport { del } from './del';\n\n// vercelBlob.head()\n\nexport type { HeadBlobResult } from './head';\nexport { head } from './head';\n\n// vercelBlob.list()\n\nexport type {\n  ListBlobResultBlob,\n  ListBlobResult,\n  ListCommandOptions,\n  ListFoldedBlobResult,\n} from './list';\nexport { list } from './list';\n\n// vercelBlob.copy()\n\nexport type { CopyBlobResult, CopyCommandOptions } from './copy';\nexport { copy } from './copy';\n"],
  "mappings": "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",
  "names": ["put", "fetch", "mapBlobResult"]
}
