import "./chunk-76J2PTFD.js";

// node_modules/@vercel/blob/dist/undici-browser.js
var fetch = globalThis.fetch;

// node_modules/@vercel/blob/dist/chunk-CU3QMXN6.js
function getTokenFromOptionsOrEnv(options) {
  if (options == null ? void 0 : options.token) {
    return options.token;
  }
  if (process.env.BLOB_READ_WRITE_TOKEN) {
    return process.env.BLOB_READ_WRITE_TOKEN;
  }
  throw new BlobError(
    "No token found. Either configure the `BLOB_READ_WRITE_TOKEN` environment variable, or pass a `token` option to your calls."
  );
}
var BlobError = class extends Error {
  constructor(message) {
    super(`Vercel Blob: ${message}`);
  }
};
var BlobAccessError = class extends BlobError {
  constructor() {
    super("Access denied, please provide a valid token for this resource");
  }
};
var BlobStoreNotFoundError = class extends BlobError {
  constructor() {
    super("This store does not exist");
  }
};
var BlobStoreSuspendedError = class extends BlobError {
  constructor() {
    super("This store has been suspended");
  }
};
var BlobUnknownError = class extends BlobError {
  constructor() {
    super("Unknown error, please visit https://vercel.com/help");
  }
};
var BlobNotFoundError = class extends BlobError {
  constructor() {
    super("The requested blob does not exist");
  }
};
async function validateBlobApiResponse(response) {
  var _a;
  if (!response.ok) {
    if (response.status >= 500) {
      throw new BlobUnknownError();
    } else {
      let data;
      try {
        data = await response.json();
      } catch {
        throw new BlobUnknownError();
      }
      const error = data.error;
      switch (error == null ? void 0 : error.code) {
        case "store_suspended":
          throw new BlobStoreSuspendedError();
        case "forbidden":
          throw new BlobAccessError();
        case "not_found":
          throw new BlobNotFoundError();
        case "store_not_found":
          throw new BlobStoreNotFoundError();
        case "bad_request":
          throw new BlobError((_a = error.message) != null ? _a : "Bad request");
        case "unknown_error":
        case "not_allowed":
        default:
          throw new BlobUnknownError();
      }
    }
  }
}
var BLOB_API_VERSION = 5;
function getApiVersionHeader() {
  let versionOverride = null;
  try {
    versionOverride = process.env.VERCEL_BLOB_API_VERSION_OVERRIDE || process.env.NEXT_PUBLIC_VERCEL_BLOB_API_VERSION_OVERRIDE;
  } catch {
  }
  return {
    "x-api-version": `${versionOverride != null ? versionOverride : BLOB_API_VERSION}`
  };
}
function getApiUrl(pathname = "") {
  let baseUrl = null;
  try {
    baseUrl = process.env.VERCEL_BLOB_API_URL || process.env.NEXT_PUBLIC_VERCEL_BLOB_API_URL;
  } catch {
  }
  return `${baseUrl || "https://blob.vercel-storage.com"}${pathname}`;
}
function createPutMethod({
  allowedOptions,
  getToken,
  extraChecks
}) {
  return async function put2(pathname, body, options) {
    if (!pathname) {
      throw new BlobError("pathname is required");
    }
    if (!body) {
      throw new BlobError("body is required");
    }
    if (!options) {
      throw new BlobError("missing options, see usage");
    }
    if (options.access !== "public") {
      throw new BlobError('access must be "public"');
    }
    if (extraChecks) {
      extraChecks(options);
    }
    const token = getToken ? await getToken(pathname, options) : getTokenFromOptionsOrEnv(options);
    const headers = {
      ...getApiVersionHeader(),
      authorization: `Bearer ${token}`
    };
    if (allowedOptions.includes("contentType") && options.contentType) {
      headers["x-content-type"] = options.contentType;
    }
    if (allowedOptions.includes("addRandomSuffix") && options.addRandomSuffix !== void 0) {
      headers["x-add-random-suffix"] = options.addRandomSuffix ? "1" : "0";
    }
    if (allowedOptions.includes("cacheControlMaxAge") && options.cacheControlMaxAge !== void 0) {
      headers["x-cache-control-max-age"] = options.cacheControlMaxAge.toString();
    }
    const blobApiResponse = await fetch(getApiUrl(`/${pathname}`), {
      method: "PUT",
      body,
      headers,
      // required in order to stream some body types to Cloudflare
      // currently only supported in Node.js, we may have to feature detect this
      duplex: "half"
    });
    await validateBlobApiResponse(blobApiResponse);
    const blobResult = await blobApiResponse.json();
    return blobResult;
  };
}

// node_modules/@vercel/blob/dist/index.js
async function del(url, options) {
  const blobApiResponse = await fetch(getApiUrl("/delete"), {
    method: "POST",
    headers: {
      ...getApiVersionHeader(),
      authorization: `Bearer ${getTokenFromOptionsOrEnv(options)}`,
      "content-type": "application/json"
    },
    body: JSON.stringify({ urls: Array.isArray(url) ? url : [url] })
  });
  await validateBlobApiResponse(blobApiResponse);
  await blobApiResponse.json();
}
async function head(url, options) {
  const headApiUrl = new URL(getApiUrl());
  headApiUrl.searchParams.set("url", url);
  const blobApiResponse = await fetch(headApiUrl, {
    method: "GET",
    // HEAD can't have body as a response, so we use GET
    headers: {
      ...getApiVersionHeader(),
      authorization: `Bearer ${getTokenFromOptionsOrEnv(options)}`
    }
  });
  await validateBlobApiResponse(blobApiResponse);
  const headResult = await blobApiResponse.json();
  return mapBlobResult(headResult);
}
function mapBlobResult(blobResult) {
  return {
    ...blobResult,
    uploadedAt: new Date(blobResult.uploadedAt)
  };
}
async function list(options) {
  var _a;
  const listApiUrl = new URL(getApiUrl());
  if (options == null ? void 0 : options.limit) {
    listApiUrl.searchParams.set("limit", options.limit.toString());
  }
  if (options == null ? void 0 : options.prefix) {
    listApiUrl.searchParams.set("prefix", options.prefix);
  }
  if (options == null ? void 0 : options.cursor) {
    listApiUrl.searchParams.set("cursor", options.cursor);
  }
  if (options == null ? void 0 : options.mode) {
    listApiUrl.searchParams.set("mode", options.mode);
  }
  const blobApiResponse = await fetch(listApiUrl, {
    method: "GET",
    headers: {
      ...getApiVersionHeader(),
      authorization: `Bearer ${getTokenFromOptionsOrEnv(options)}`
    }
  });
  await validateBlobApiResponse(blobApiResponse);
  const results = await blobApiResponse.json();
  if ((options == null ? void 0 : options.mode) === "folded") {
    return {
      folders: (_a = results.folders) != null ? _a : [],
      cursor: results.cursor,
      hasMore: results.hasMore,
      blobs: results.blobs.map(mapBlobResult2)
    };
  }
  return {
    cursor: results.cursor,
    hasMore: results.hasMore,
    blobs: results.blobs.map(mapBlobResult2)
  };
}
function mapBlobResult2(blobResult) {
  return {
    ...blobResult,
    uploadedAt: new Date(blobResult.uploadedAt)
  };
}
async function copy(fromUrl, toPathname, options) {
  if (!options) {
    throw new BlobError("missing options, see usage");
  }
  if (options.access !== "public") {
    throw new BlobError('access must be "public"');
  }
  const headers = {
    ...getApiVersionHeader(),
    authorization: `Bearer ${getTokenFromOptionsOrEnv(options)}`
  };
  if (options.addRandomSuffix !== void 0) {
    headers["x-add-random-suffix"] = options.addRandomSuffix ? "1" : "0";
  }
  if (options.contentType) {
    headers["x-content-type"] = options.contentType;
  }
  if (options.cacheControlMaxAge !== void 0) {
    headers["x-cache-control-max-age"] = options.cacheControlMaxAge.toString();
  }
  const blobApiResponse = await fetch(
    getApiUrl(`/${toPathname}?fromUrl=${fromUrl}`),
    { method: "PUT", headers }
  );
  await validateBlobApiResponse(blobApiResponse);
  return await blobApiResponse.json();
}
var put = createPutMethod({
  allowedOptions: ["cacheControlMaxAge", "addRandomSuffix", "contentType"]
});
export {
  BlobAccessError,
  BlobError,
  BlobNotFoundError,
  BlobStoreNotFoundError,
  BlobStoreSuspendedError,
  BlobUnknownError,
  copy,
  del,
  head,
  list,
  put
};
//# sourceMappingURL=@vercel_blob.js.map
